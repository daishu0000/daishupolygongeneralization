# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DaishuPolygonGeneralizationDialog
                                 A QGIS plugin
 a polygon generalization tool developed by daishu.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-11-28
        git sha              : $Format:%H$
        copyright            : (C) 2024 by daishu
        email                : daishu10000@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import hashlib
import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets

from qgis.core import (
    QgsWkbTypes,
    QgsRectangle,
    QgsProject,          # 用于将图层添加到项目
    QgsVectorLayer,      # 创建矢量图层
    QgsField,            # 定义属性字段
    QgsFeature,          # 创建要素
    QgsGeometry,         # 几何操作
    QgsLineString,       # 线几何类型
    QgsPointXY,
    QgsFeatureRequest

)
from PyQt5.QtCore import QTimer
from qgis.PyQt.QtCore import QVariant  # 用于属性字段的数据类型

import processing
# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'daishuPolygonGeneralization_dialog_base.ui'))


class DaishuPolygonGeneralizationDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(DaishuPolygonGeneralizationDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.pbGeneralize.clicked.connect(self.onPbGeneralizeClicked)
        self.pbStep.clicked.connect(self.onpbStepClicked)

        self.pbPoint.clicked.connect(self.onPbPointClicked)
        self.pbDelaunay.clicked.connect(self.onPbDelaunayClicked)
        self.pbReduction.clicked.connect(self.onPbReductionClicked)
        self.pbMerge.clicked.connect(self.onPbMergeClicked)
        self.pbFillPolygon.clicked.connect(self.onPbFillPolygonClicked)
        self.pbSimplify.clicked.connect(self.onPbSimplifyClicked)

    def onPbGeneralizeClicked(self):
        currLayer=self.mlLayer.currentLayer()
        crs = currLayer.crs()
        crs_auth_id = crs.authid()  # 获取参考系的 EPSG 代码，例如 "EPSG:4326"

        warningLabel=self.lblWarning
        if self.check_layer_type(currLayer,warningLabel)==1:
            if currLayer is not None and currLayer.isValid():
                # 确保图层是矢量图层
                if currLayer.geometryType() == QgsWkbTypes.PolygonGeometry:
                    bounds=self.get_layer_bounds(currLayer)
                    if bounds is None:
                        return
                    width=bounds.width()
                    height=bounds.height()

                    pic=min(width,height)/200

                    print(pic)
                    point_layer=self.generate_points(pic,currLayer,crs_auth_id)
                    triangulation_layer=self.generate_delaunay_triangulation(point_layer,crs_auth_id)
                    reduce_layer=self.reduce_triangulation(triangulation_layer,0.9)
                    merged_layer=self.merge_triangulation(reduce_layer)
                    full_layer=self.fulfillPolygon(merged_layer)
                    fixed_convex_hull_layer=self.simpifyPolygonWithConvexHull(full_layer)
                    warningLabel.setText("生成完成")
                else:
                    print("当前图层不是面图层！")
            else:
                print("图层无效！")
    step=0
    crs=None
    layer=None
    pic=None
    def onpbStepClicked(self):
        if self.step==0:
            self.step0()
            self.step=1
        elif self.step==1:
            self.step1()
            self.step=2
        elif self.step == 2:
            self.step2()
            self.step = 3
        elif self.step == 3:
            self.step3()
            self.step = 4
        elif self.step == 4:
            self.step4()
            self.step = 5
        elif self.step == 5:
            self.step5()
            self.step = 6
        return

    def step0(self):
        currLayer=self.mlLayer.currentLayer()
        crs = currLayer.crs()
        crs_auth_id = crs.authid()  # 获取参考系的 EPSG 代码，例如 "EPSG:4326"

        warningLabel=self.lblWarning
        warningLabel.setText("1.正在生成点")
        if self.check_layer_type(currLayer,warningLabel)==1:
            if currLayer is not None and currLayer.isValid():
                # 确保图层是矢量图层
                if currLayer.geometryType() == QgsWkbTypes.PolygonGeometry:
                    bounds=self.get_layer_bounds(currLayer)
                    if bounds is None:
                        return
                    width=bounds.width()
                    height=bounds.height()

                    pic=min(width,height)/100
                    self.pic=pic
                    self.crs=crs_auth_id
                    self.layer=self.generate_points(pic,currLayer,crs_auth_id)
                    warningLabel.setText("1.点生成完成")
                    return self.layer
                else:
                    print("当前图层不是面图层！")
            else:
                print("图层无效！")

    def step1(self):
        warningLabel=self.lblWarning
        warningLabel.setText("2.正在生成delaunay三角网...")
        self.layer = self.generate_delaunay_triangulation(self.layer, self.crs)
        warningLabel.setText("2.delaunay三角网生成完成")
    def step2(self):
        warningLabel=self.lblWarning
        warningLabel.setText("3.正在剪枝...")
        self.layer=self.reduce_triangulation(self.layer,0.9)
        warningLabel.setText("3.剪枝完成")
    def step3(self):
        warningLabel=self.lblWarning
        warningLabel.setText("4.正在合并...")
        self.layer=self.merge_triangulation(self.layer)
        warningLabel.setText("4.合并完成")
    def step4(self):
        warningLabel=self.lblWarning
        warningLabel.setText("5.正在填充多边形...")
        self.layer=self.fulfillPolygon(self.layer)
        warningLabel.setText("5.填充多边形完成")

    def step5(self):
        warningLabel=self.lblWarning
        warningLabel.setText("6.正在简化多边形...")
        self.layer=self.simpifyPolygonWithConvexHull(self.layer)
        warningLabel.setText("6.简化多边形完成")

    def check_layer_type(self,layer,warningLabel):

        # 获取几何类型
        wkb_type = layer.wkbType()
        geometry_type = QgsWkbTypes.geometryType(wkb_type)

        # 根据几何类型输出图层类型
        if geometry_type == QgsWkbTypes.PointGeometry:
            print("这是一个点图层")
            warningLabel.setText("不能是点图层")
        elif geometry_type == QgsWkbTypes.LineGeometry:
            print("这是一个线图层")
            warningLabel.setText("不能是线图层")
        elif geometry_type == QgsWkbTypes.PolygonGeometry:
            return 1
        else:
            print("未知类型的矢量图层")

        # 打印更详细的 WKB 信息
        wkb_name = QgsWkbTypes.displayString(wkb_type)
        print(f"详细类型：{wkb_name}")
        return 0

    def get_layer_bounds(self,layer):
        # 初始化范围变量
        total_extent = None

        # 遍历图层中的所有要素
        for feature in layer.getFeatures():
            geometry = feature.geometry()
            if geometry is not None:
                # 获取要素的范围
                bbox = geometry.boundingBox()

                # 合并范围
                if total_extent is None:
                    total_extent = QgsRectangle(bbox)
                else:
                    total_extent.combineExtentWith(bbox)

        if total_extent:
            return total_extent
        else:
            print("图层没有有效的范围")
            return None
    def generate_points(self,pic,layer,crs):
        # 创建一个临时点图层用于存放生成的点
        point_layer = QgsVectorLayer("Point?crs="+crs, "Generated Points", "memory")
        point_provider = point_layer.dataProvider()

        # 设置属性表（可选）
        point_provider.addAttributes([QgsField("polygon_id", QVariant.Int)])
        point_layer.updateFields()

        for feature in layer.getFeatures():
            geom = feature.geometry()
            if geom is None or not geom.isGeosValid():
                continue

            # 获取外环和内环
            polygons = geom.constParts()

            for polygon in polygons:

                boundary_line = polygon.boundary()
                points = list(boundary_line.vertices())

                lastPoint=None
                # 遍历边界上的每个点
                for point in points:
                    # 将 QgsPoint 转换为 QgsPointXY
                    point_xy = QgsPointXY(point)

                    if lastPoint is not None:
                        distance = lastPoint.distance(point_xy)
                        if distance>pic:
                            num_points = int(distance // pic)  # 计算需要插入的点数
                            for i in range(1, num_points + 1):
                                # 插值点按比例计算
                                interpolated_point = QgsPointXY(
                                    lastPoint.x() + (point_xy.x() - lastPoint.x()) * i / (num_points + 1),
                                    lastPoint.y() + (point_xy.y() - lastPoint.y()) * i / (num_points + 1)
                                )
                                # 创建一个 QgsFeature 并设置几何和属性
                                point_feature = QgsFeature()
                                point_feature.setGeometry(
                                    QgsGeometry.fromPointXY(interpolated_point))  # 使用 QgsPointXY 创建几何
                                point_feature.setAttributes([feature.id()])  # 设置 polygon_id 属性

                                # 将插值点添加到图层
                                point_provider.addFeature(point_feature)

                    # 创建一个 QgsFeature 并设置几何和属性
                    point_feature = QgsFeature()
                    point_feature.setGeometry(QgsGeometry.fromPointXY(point_xy))  # 使用 QgsPointXY 创建几何
                    point_feature.setAttributes([feature.id()])  # 设置 polygon_id 属性

                    # 将点添加到图层
                    point_provider.addFeature(point_feature)
                    lastPoint=point_xy
        # 将临时图层添加到地图中
        QgsProject.instance().addMapLayer(point_layer)
        print(f"生成的点已添加到图层：{point_layer.name()}")
        return point_layer

    def generate_delaunay_triangulation(self, point_layer, crs):
        # 创建一个临时图层来保存 Delaunay 三角网
        triangulation_layer = QgsVectorLayer("Polygon?crs=" + crs, "Delaunay Triangulation", "memory")
        triangulation_provider = triangulation_layer.dataProvider()

        # 添加属性字段（可选）
        triangulation_provider.addAttributes([
            QgsField("triangle_id", QVariant.Int),
            QgsField("point_1", QVariant.Int),
            QgsField("point_2", QVariant.Int),
            QgsField("point_3", QVariant.Int)
        ])
        triangulation_layer.updateFields()

        # 提取 point_layer 中的所有点
        points = []
        point_id_map = {}
        for feature in point_layer.getFeatures():
            point = feature.geometry().centroid().asPoint()  # 获取点的中心
            polygon_id = feature['polygon_id']  # 获取 polygon_id 属性
            points.append(QgsPointXY(point.x(), point.y()))  # 获取点的 x, y 坐标
            point_id_map[len(points) - 1] = polygon_id  # 记录点的 ID 和 polygon_id
        print("delaunay多边形建立:属性表生成完成")
        # 创建 QgsGeometry 对象
        geometry = QgsGeometry.fromPolylineXY(points)

        # 生成 Delaunay 三角剖分
        triangulation = QgsGeometry.delaunayTriangulation(geometry)

        # 遍历 GeometryCollection 中的每个三角形并将其添加到图层
        triangle_id = 1
        for geom in triangulation.asGeometryCollection():
            if geom.type() == QgsWkbTypes.PolygonGeometry:
                if triangle_id%100==0:
                    print("正在添加第"+str(triangle_id)+"个多边形")
                # 获取三角形的三个顶点
                vertices = geom.asPolygon()[0]

                # 根据点的顺序获取对应的 polygon_id
                point_1_id = point_id_map[points.index(QgsPointXY(vertices[0].x(), vertices[0].y()))]
                point_2_id = point_id_map[points.index(QgsPointXY(vertices[1].x(), vertices[1].y()))]
                point_3_id = point_id_map[points.index(QgsPointXY(vertices[2].x(), vertices[2].y()))]

                # 创建一个新的要素
                feature = QgsFeature()
                feature.setGeometry(geom)

                # 设置属性字段
                feature.setAttributes([triangle_id, point_1_id, point_2_id, point_3_id])

                # 将要素添加到图层
                triangulation_provider.addFeature(feature)

                triangle_id += 1

        # 刷新图层以显示更改
        triangulation_layer.updateExtents()
        QgsProject.instance().addMapLayer(triangulation_layer)
        print("delaunay多边形建立:图层已更改")
        return triangulation_layer

    def reduce_triangulation(self,triangulation_layer,magnification):
        total_length = 0  # 总长度
        count = 0  # 计数器，用于计算平均长度

        for feature in triangulation_layer.getFeatures():
            geom = feature.geometry()
            if geom is None or not geom.isGeosValid():
                continue

            # 获取外环和内环
            polygons = geom.constParts()

            for polygon in polygons:
                boundary_line = polygon.boundary()
                boundary_length = boundary_line.length()  # 获取边界线的长度
                total_length += boundary_length  # 累加到总长度
                count += 1  # 增加计数器

            # 计算平均长度
            if count > 0:
                average_length = total_length / count
            else:
                average_length = 0

        # 创建一个新的临时图层
        crs = triangulation_layer.crs()  # 获取原图层的坐标参考系统
        reduce_layer = QgsVectorLayer('Polygon?crs={}'.format(crs.authid()), 'Reduced Triangles', 'memory')

        # 获取数据提供者（用于添加和删除特征）
        provider = reduce_layer.dataProvider()

        reduce_layer.startEditing()  # 开始编辑
        for field in triangulation_layer.fields():
            provider.addAttributes([field])  # 添加字段
        reduce_layer.updateFields()  # 更新字段
        reduce_layer.commitChanges()  # 提交修改

        # 存储边长大于平均长度三倍的三角形
        to_keep_features = []

        # 查找并保留边长小于等于平均长度三倍的三角形
        for feature in triangulation_layer.getFeatures():
            geom = feature.geometry()
            if geom is None or not geom.isGeosValid():
                continue

            # 获取外环和内环
            polygons = geom.constParts()

            for polygon in polygons:
                boundary_line = polygon.boundary()
                boundary_length = boundary_line.length()  # 获取边界线的长度
                if boundary_length <= magnification*average_length:  # 保留边长小于等于平均长度三倍的三角形

                    to_keep_features.append(feature)  # 将该三角形加入保留列表
                else:
                    point_1 = feature['point_1']
                    point_2 = feature['point_2']
                    point_3 = feature['point_3']
                    # 如果 point_1, point_2, point_3 相同
                    if point_1 == point_2 == point_3:
                        to_keep_features.append(feature)  # 将该三角形加入保留列表

        # 向临时图层添加特征
        provider.addFeatures(to_keep_features)

        # 更新图层
        reduce_layer.updateExtents()

        QgsProject.instance().addMapLayer(reduce_layer)

        return reduce_layer

    def merge_triangulation(self,reduce_layer):
        crs = reduce_layer.crs()  # 获取原图层的坐标参考系统

        polygons=[]
        i=0
        # 遍历图层中的所有要素
        for feature in reduce_layer.getFeatures():
            i+=1
            if i%100==0:
                print("正在处理第"+str(i)+"个多边形")
            # 获取每个多边形的属性值
            point_1 = feature['point_1']
            point_2 = feature['point_2']
            point_3 = feature['point_3']
            triangle_id = feature['triangle_id']

            polygons.append({'point_1':point_1,'point_2':point_2,'point_3':point_3,'triangle_id':triangle_id})
        grouped=self.geo_merge(polygons)

        merged_layer = QgsVectorLayer('Polygon?crs={}'.format(crs.authid()), 'merged_layer', 'memory')
        provider = merged_layer.dataProvider()

        print("总共"+str(len(grouped))+"组")
        j=0
        for group in grouped.values():
            j+=1
            print("合并:处理第"+str(j)+"组")
            merged_geometry = QgsGeometry.fromWkt('MULTIPOLYGON EMPTY')
            for feature in group:
                polygonId=feature['triangle_id']
                # 设置你要查找的属性字段名和属性值
                field_name = 'triangle_id'
                value_to_find = polygonId

                # 创建查询请求（筛选器）
                request = QgsFeatureRequest().setFilterExpression(f'"{field_name}" = \'{value_to_find}\'')

                # 查找符合条件的要素
                feature =next(reduce_layer.getFeatures(request))

                if feature:
                    # 获取多边形的几何并合并到已有的几何中
                    geometry = feature.geometry()
                    if merged_geometry.isEmpty():
                        merged_geometry = geometry
                    else:
                        merged_geometry = merged_geometry.combine(geometry)
            # 将合并后的几何添加到新图层
            if not merged_geometry.isEmpty():
                new_feature = QgsFeature()
                new_feature.setGeometry(merged_geometry)
                provider.addFeature(new_feature)

        # 更新图层
        merged_layer.updateExtents()
        QgsProject.instance().addMapLayer(merged_layer)

        print("多边形合并:已完成")
        # 返回合并后的图层
        return merged_layer


    def encode_record(self,a, b, c):
        record = f"{a}-{b}-{c}"
        return int(hashlib.md5(record.encode()).hexdigest(), 16)  # 将MD5哈希值转换为整数

    def geo_merge_find(self,parent, i):
        if parent[i] != i:
            parent[i] = self.geo_merge_find(parent, parent[i])  # 路径压缩
        return parent[i]

    def geo_merge_union(self,parent, rank, x, y):
        rootX = self.geo_merge_find(parent, x)
        rootY = self.geo_merge_find(parent, y)
        if rootX != rootY:
            if rank[rootX] > rank[rootY]:
                parent[rootY] = rootX
            elif rank[rootX] < rank[rootY]:
                parent[rootX] = rootY
            else:
                parent[rootY] = rootX
                rank[rootX] += 1

    def geo_merge(self,objects):
        # 初始化并查集
        parent = [i for i in range(len(objects))]
        rank = [0] * len(objects)

        # 对每个属性分别排序并检查相邻对象
        for attr in ['point_1', 'point_2', 'point_3']:
            sorted_objects = sorted(enumerate(objects), key=lambda x: x[1][attr])
            for i in range(1, len(sorted_objects)):
                if sorted_objects[i][1][attr] == sorted_objects[i - 1][1][attr]:
                    self.geo_merge_union(parent, rank, sorted_objects[i][0], sorted_objects[i - 1][0])

        # 分类输出
        grouped = {}
        for i, obj in enumerate(objects):
            root = self.geo_merge_find(parent, i)
            if root not in grouped:
                grouped[root] = []
            grouped[root].append(obj)

        return grouped

    def fulfillPolygon(self,merged_layer):
        crs = merged_layer.crs()  # 获取原图层的坐标参考系统
        warningLabel=self.lblWarning
        print("正在填充")
        if self.check_layer_type(merged_layer,warningLabel)==1:
            if merged_layer is not None and merged_layer.isValid():
                # 确保图层是矢量图层
                if merged_layer.geometryType() == QgsWkbTypes.PolygonGeometry:
                    # 创建新的图层，用于存储去除内部环的多边形
                    full_layer = QgsVectorLayer('Polygon?crs={}'.format(crs.authid()), 'Full Polygons', 'memory')
                    new_provider = full_layer.dataProvider()
                    new_provider.addAttributes([QgsField('id', QVariant.Int)])
                    full_layer.updateFields()

                    # 遍历当前图层的所有要素
                    for feature in merged_layer.getFeatures():
                        geom = feature.geometry()

                        if geom.isMultipart():
                            # 获取所有的多部分多边形（外环和内环）
                            parts = geom.asMultiPolygon()
                            for part in parts:
                                outer_ring = part[0]  # 外环
                                # 将外环创建成一个新的多边形
                                new_geom = QgsGeometry.fromPolygonXY([outer_ring])

                                # 创建新的特征并设置其几何信息
                                new_feature = QgsFeature()
                                new_feature.setGeometry(new_geom)
                                new_feature.setAttributes([feature.id()])

                                # 将新的特征添加到新图层
                                new_provider.addFeature(new_feature)
                        else:
                            # 单个多边形的处理
                            outer_ring = geom.asPolygon()[0]  # 获取外环
                            new_geom = QgsGeometry.fromPolygonXY([outer_ring])

                            # 创建新的特征并设置其几何信息
                            new_feature = QgsFeature()
                            new_feature.setGeometry(new_geom)
                            new_feature.setAttributes([feature.id()])

                            # 将新的特征添加到新图层
                            new_provider.addFeature(new_feature)

                    # 更新新图层的显示
                    QgsProject.instance().addMapLayer(full_layer)
                    print("填充完成")
                    return full_layer
                else:
                    print("当前图层不是面图层！")
            else:
                print("图层无效！")

        return

    def simpifyPolygonWithConvexHull(self,full_layer):
        convex_hull_layer=self.calculate_convex_hull(full_layer)
        fixed_layer=self.fix_convex_hull(convex_hull_layer)
        fixed_convex_hull_layer=self.calculate_convex_hull(fixed_layer)
        return fixed_convex_hull_layer
    def simplifyPolygon(self,full_layer,tolerance,type):
        # 使用 'simplifygeometries' 算法简化多边形
        params = {
            'INPUT': full_layer,
            'METHOD': type, #0:道格拉斯普客，1:基于格网，2:基于面积
            'TOLERANCE': tolerance,
            'OUTPUT': 'memory:'  # 结果保存在内存中
        }

        result = processing.run("native:simplifygeometries", params)
        simplified_layer = result['OUTPUT']

        # 将简化后的图层添加到QGIS中
        QgsProject.instance().addMapLayer(simplified_layer)

        return simplified_layer
    def calculate_convex_hull(self,full_layer):
        crs = full_layer.crs()  # 获取原图层的坐标参考系统
        # 创建一个临时内存图层来存储凸包结果
        convex_hull_layer = QgsVectorLayer('Polygon?crs={}'.format(crs.authid()), "Convex_Hulls", "memory")
        provider = convex_hull_layer.dataProvider()

        # 复制输入图层的字段定义到新的凸包图层
        provider.addAttributes(full_layer.fields())
        convex_hull_layer.updateFields()  # 更新字段

        # 开始编辑会话
        convex_hull_layer.startEditing()

        for feature in full_layer.getFeatures():
            geom = feature.geometry()
            if geom is not None:
                hull_geom = geom.convexHull()  # 计算凸包

                # 创建新的特征，并设置几何和属性
                new_feature = QgsFeature()
                new_feature.setGeometry(hull_geom)
                new_feature.setAttributes(feature.attributes())  # 保留原始属性

                # 添加到图层
                convex_hull_layer.addFeature(new_feature)

        # 提交更改结束编辑会话
        convex_hull_layer.commitChanges()

        # 将新图层添加到当前项目
        QgsProject.instance().addMapLayer(convex_hull_layer)
        return convex_hull_layer


    def fix_convex_hull(self, convex_hull_layer):
        crs = convex_hull_layer.crs()  # 获取原图层的坐标参考系统
        # 创建一个临时内存图层来存储凸包结果
        fixed_layer = QgsVectorLayer('Polygon?crs={}'.format(crs.authid()), "Convex_Hulls", "memory")
        provider = fixed_layer.dataProvider()

        # 复制输入图层的字段定义到新的凸包图层
        provider.addAttributes(convex_hull_layer.fields())
        fixed_layer.updateFields()  # 更新字段

        # 开始编辑会话
        fixed_layer.startEditing()

        # 初始化两个列表，用于存储独立的多边形和需要合并的多边形集合
        independent_geoms = []
        processed_features = set()  # 跟踪已处理的要素

        # 遍历所有的多边形特征
        for feature in convex_hull_layer.getFeatures():
            if feature.id() in processed_features:
                continue

            geom = feature.geometry()
            to_merge = [geom]  # 准备合并的几何体列表

            # 查找所有与当前几何体相交的几何体并准备合并
            for other_feature in convex_hull_layer.getFeatures():
                if other_feature.id() != feature.id() and other_feature.id() not in processed_features:
                    other_geom = other_feature.geometry()
                    if geom.intersects(other_geom):
                        to_merge.append(other_geom)
                        processed_features.add(other_feature.id())  # 标记为已处理

            # 合并与相交的多边形
            merged_geom = QgsGeometry.unaryUnion(to_merge) if len(to_merge) > 1 else geom

            # 添加合并后的多边形为一个要素（如果有的话）
            if not merged_geom.isEmpty():
                feat = QgsFeature()
                feat.setGeometry(merged_geom)
                provider.addFeature(feat)

            # 将当前要素标记为已处理
            processed_features.add(feature.id())

        # 提交更改结束编辑会话
        fixed_layer.commitChanges()

        # 将新图层添加到当前项目
        QgsProject.instance().addMapLayer(fixed_layer)

        return fixed_layer

    def onPbPointClicked(self):
        self.mlLayer.setLayer(self.step0())
        return
    # def onPbDelaunayClicked(self):
    #     warningLabel=self.lblWarning
    #     warningLabel.setText("2.正在生成delaunay三角网...")
    #     currLayer=self.mlLayer.currentLayer()
    #     crs = currLayer.crs().authid()
    #     self.mlLayer.setLayer(self.generate_delaunay_triangulation(currLayer,crs))
    #     warningLabel.setText("2.delaunay三角网生成完成")
    #     return
    # def onPbReductionClicked(self):
    #     warningLabel=self.lblWarning
    #     warningLabel.setText("3.正在剪枝...")
    #     currLayer=self.mlLayer.currentLayer()
    #     self.mlLayer.setLayer(self.reduce_triangulation(currLayer,0.9))
    #     warningLabel.setText("3.剪枝完成")
    #     return
    # def onPbMergeClicked(self):
    #     warningLabel=self.lblWarning
    #     warningLabel.setText("4.正在合并...")
    #     currLayer=self.mlLayer.currentLayer()
    #     self.mlLayer.setLayer(self.merge_triangulation(currLayer))
    #     warningLabel.setText("4.合并完成")
    #     return
    # def onPbFillPolygonClicked(self):
    #     warningLabel=self.lblWarning
    #     warningLabel.setText("5.正在填充多边形...")
    #     currLayer=self.mlLayer.currentLayer()
    #     self.mlLayer.setLayer(self.fulfillPolygon(currLayer))
    #     warningLabel.setText("5.填充多边形完成")
    #     return
    # def onPbSimplifyClicked(self):
    #     warningLabel=self.lblWarning
    #     warningLabel.setText("6.正在简化多边形...")
    #     currLayer=self.mlLayer.currentLayer()
    #     self.mlLayer.setLayer(self.simpifyPolygonWithConvexHull(currLayer))
    #     warningLabel.setText("6.简化多边形完成")
    #     return

    def update_and_process(self, warningLabel, message, process_func, *args):
        """Helper function to update the UI and then process."""
        warningLabel.setText(message)
        QTimer.singleShot(500, lambda: self._process_with_update(warningLabel, message,process_func, *args))

    def _process_with_update(self, warningLabel, message,process_func, *args):
        """Internal method to perform the processing after the UI has been updated."""
        currLayer = self.mlLayer.currentLayer()
        new_layer = process_func(currLayer, *args)
        self.mlLayer.setLayer(new_layer)
        warningLabel.setText(f"{message.split('.')[0]}.{message.split('.')[1].split('在')[1]}完成")

    def onPbDelaunayClicked(self):
        self.update_and_process(
            self.lblWarning,
            "2.正在生成delaunay三角网...",
            self.generate_delaunay_triangulation,
            self.mlLayer.currentLayer().crs().authid()
        )

    def onPbReductionClicked(self):
        self.update_and_process(
            self.lblWarning,
            "3.正在剪枝...",
            self.reduce_triangulation,
            0.9
        )

    def onPbMergeClicked(self):
        self.update_and_process(
            self.lblWarning,
            "4.正在合并...",
            self.merge_triangulation
        )

    def onPbFillPolygonClicked(self):
        self.update_and_process(
            self.lblWarning,
            "5.正在填充多边形...",
            self.fulfillPolygon
        )

    def onPbSimplifyClicked(self):
        self.update_and_process(
            self.lblWarning,
            "6.正在简化多边形...",
            self.simpifyPolygonWithConvexHull
        )
